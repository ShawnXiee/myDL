1.基础
数组类numpy.ndarray
属性:
ndarray.ndim: 维度
ndarray.shape: 一个tuple表明每一维度的长度,len(ndarray.shape) == ndarray.ndim
ndarray.size: 数组元素个数,等于shape属性所有值的积
ndarray.dtype: 数据元素类型
ndarray.itemsize: 每个元素大小,即占用的字节数
ndarray.data: 包含数组元素的buff

2.创建数组的几种方式:
(1)用一个列表或者tuple初始化
a  = np.array([2,3,4])
b  = np.array((2,3,4))

(2)创建多维数组
In [20]: c = np.array([[1, 3, 5, 9], (2, 4, 6)])

In [21]: c
Out[21]: array([list([1, 3, 5, 9]), (2, 4, 6)], dtype=object)

(3)指定元素类型
In [30]:  d = np.array([[1+2j, 2], [3, 4]], dtype=complex)

In [31]: d
Out[31]:
array([[1.+2.j, 2.+0.j],
       [3.+0.j, 4.+0.j]])

(4)初始化全为0的数组
In [36]: e = np.zeros((3, 2, 1))

In [37]: e
Out[37]:
array([[[0.],
        [0.]],

       [[0.],
        [0.]],

       [[0.],
        [0.]]])

(5)初始化全为1的数组
In [40]:  f = np.ones((2,3))

In [41]: f
Out[41]:
array([[1., 1., 1.],
       [1., 1., 1.]])

(6)初始化一个空数组,生成的值没有意义,所以是生成数组最快的方式
In [2]: a = np.empty((2,3))

In [3]: a
Out[3]:
array([[  6.92346528e-310,   6.92346528e-310,   3.32457344e-309],
       [  6.92346242e-310,   6.92343567e-310,   1.41017086e-316]])

(7)根据数字序列生成数组,也接受float参数
In [6]: a = np.arange(1, 5, 2)

In [7]: a
Out[7]: array([1, 3])

只有一个参数时为从0到该值的序列,两个参数时为区间,间隔默认为1, 如果有第三个参数则为间隔值.

(8)在指定float类型的step时,由于精度原因,不能预测得到的元素个数,使用linspace
In [15]: b
Out[15]: array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])
发现此时区间是闭合区间,而之前的区间都是半闭半开区间.

(9)输出数组
In [6]: b = np.arange(12).reshape(3, 4)

In [7]: print b
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]

 (10)基本操作

减法:
In [12]: a = np.array([20, 30, 40, 50])
In [14]: b =  np.arange(4)

In [15]: b
Out[15]: array([0, 1, 2, 3])

In [16]: c = a - b
In [17]: print (c)
[20 29 38 47]

阶乘:
In [21]:  a**2
Out[21]: array([ 400,  900, 1600, 2500])

比较:
In [24]: a < 35
Out[24]: array([ True,  True, False, False], dtype=bool)

* 运算符为对应位置相乘
In [26]: A = np.array([[1, 1], [0, 1]])

In [27]: B  = np.array([[2, 0], [3, 4]])

In [28]: A*B
Out[28]:
array([[2, 0],
       [0, 4]])

矩阵相乘用dot
In [29]: A.dot(B)
Out[29]:
array([[5, 4],
       [3, 4]])

In [30]: np.dot(A, B)
Out[30]:
array([[5, 4],
       [3, 4]])

求和函数:
n [35]: b
Out[35]:
array([[ 0.64184347,  0.51248687,  0.47530203],
       [ 0.7733037 ,  0.44748266,  0.16079177]])

In [36]: b.sum()
Out[36]: 3.0112105007183416

求极值:
In [37]: b.max()
Out[37]: 0.77330370262198955

In [38]: b.min()
Out[38]: 0.16079177251266685

多维数组时, 通过指定axis为0以列为操作对象,axis为1以行为操作对象
In [40]: b
Out[40]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [43]: b.sum(axis=0)
Out[43]: array([12, 15, 18, 21])

In [44]: b.sum(axis=1)
Out[44]: array([ 6, 22, 38])

In [45]:  b.max(axis=0)
Out[45]: array([ 8,  9, 10, 11])

依次叠加每行或者列.
In [47]:  b.cumsum(axis=1)
Out[47]:
array([[ 0,  1,  3,  6],
       [ 4,  9, 15, 22],
       [ 8, 17, 27, 38]])


(11)通用函数

In [3]: a
Out[3]: array([ 0,  1,  4,  9, 16, 25, 36, 49, 64, 81])

下标运算
In [4]: a[2]
Out[4]: 4

切片
In [5]: a[2:5]
Out[5]: array([ 4,  9, 16])

倒叙
In [6]: a[::-1]
Out[6]: array([81, 64, 49, 36, 25, 16,  9,  4,  1,  0])

迭代
In [7]: for i in a:
   ...:     print i
   ...:
0
1
4
9
16
25
36
49
64
81

自定义函数
In [9]: def f(x, y):
   ...:     return 2*x + y
   ...:

In [10]: b = np.fromfunction(f, (4, 3), dtype=int)

In [11]: b
Out[11]:
array([[0, 1, 2],
       [2, 3, 4],
       [4, 5, 6],
       [6, 7, 8]])

多级索引
In [13]: b[1, 2]
Out[13]: 4

In [14]: b[1][2]
Out[14]: 4

负数索引:

In [15]: b[-1]
Out[15]: array([6, 7, 8])

遍历多维数组

In [16]: for row in b:
   ....:     print row
   ....:
[0 1 2]
[2 3 4]
[4 5 6]
[6 7 8]

In [17]: for element in b.fl
b.flags    b.flat     b.flatten

In [17]: for element in b.flat:
   ....:     print element
   ....:
0
1
2
2
3
4
4
5
6
6
7
8


np.floor()
返回每个元素最靠近0的下一个整数

np.ravel() vs np.flatten
二者都是将多维数组降为一维数组,区别在于np.ravel()返回的是原数组的视图
对一维数组的修改会影响原始矩阵,而np.flatten返回的是拷贝,不会影响原始矩阵.

 
矩阵转置

In [57]: b
Out[57]:
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

In [58]: b.T
Out[58]:
array([[0, 5],
       [1, 6],
       [2, 7],
       [3, 8],
       [4, 9]])

矩阵叠加
In [64]: b
Out[64]:
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

In [65]: c = b*2

In [66]: c
Out[66]:
array([[ 0,  2,  4,  6,  8],
       [10, 12, 14, 16, 18]])

In [67]: np.vstack((b, c))
Out[67]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [ 0,  2,  4,  6,  8],
       [10, 12, 14, 16, 18]])

In [68]: np.hstack((b, c))
Out[68]:
array([[ 0,  1,  2,  3,  4,  0,  2,  4,  6,  8],
       [ 5,  6,  7,  8,  9, 10, 12, 14, 16, 18]])

两个一维矩阵使用hstack结果还是一维矩阵
In [103]: a
Out[103]: array([1, 3])

In [104]: b
Out[104]: array([2, 4])

In [105]: np.hstack((a, b))
Out[105]: array([1, 3, 2, 4])


In [106]: np.vstack((a, b))
Out[106]:
array([[1, 3],
       [2, 4]])

In [108]: np.row_stack((a, b))
Out[108]:
array([[1, 3],
       [2, 4]])


In [107]: np.column_stack((a, b))
Out[107]:
array([[1, 2],
       [3, 4]])

指定维度升维
In [110]: a[: ,newaxis]
Out[110]:
array([[1],
       [3]])

In [112]: a[newaxis ,:]
Out[112]: array([[1, 3]])


r_和c_

c_将矩阵按列连接,要有矩阵行数相等
In [42]: np.c_[a, a]
Out[42]: 
array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])

r_将矩阵按行连接,要求矩阵列数相等
In [21]: a
Out[21]: 
array([[0, 1, 2],
       [3, 4, 5]])

In [22]: np.r_[a, a]
Out[22]: 
array([[0, 1, 2],
       [3, 4, 5],
       [0, 1, 2],
       [3, 4, 5]])

通过参数指定r_的连接维数,默认为0,即行连接, 1为列数.
In [23]: np.r_['-1', a, a]
Out[23]: 
array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])

In [24]: np.r_['0', a, a]
Out[24]: 
array([[0, 1, 2],
       [3, 4, 5],
       [0, 1, 2],
       [3, 4, 5]])

In [25]: np.r_['1', a, a]
Out[25]: 
array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])

当有两个参数时,第一个参数指定连接维度,第二个参数指定新矩阵的最小维度
In [26]: a = np.r_['0,2', [1,2,3], [4,5,6]]

In [27]: a
Out[27]: 
array([[1, 2, 3],
       [4, 5, 6]])

In [28]: a = np.r_['0,3', [1,2,3], [4,5,6]]
0表示按照行连接,3表示新矩阵维度至少为3

In [29]: a
Out[29]: 
array([[[1, 2, 3]],

       [[4, 5, 6]]])

当有三个参数时,前两个参数参照2个参数的情况,第三个参数指定新条目在新矩阵中的维度.
In [47]: np.r_['0,2,0', [1,2,3], [4,5,6]]
Out[47]: 
array([[1],
       [2],
       [3],
       [4],
       [5],
       [6]])

In [48]: np.r_['1,2,0', [1,2,3], [4,5,6]]
Out[48]: 
array([[1, 4],
       [2, 5],
       [3, 6]])

In [49]: np.r_['1,2,1', [1,2,3], [4,5,6]]
Out[49]: array([[1, 2, 3, 4, 5, 6]])

生成随机矩阵,2,3为shape
In [52]:  b = np.random.random((2, 3))

In [53]: b
Out[53]: 
array([[ 0.66039564,  0.8441633 ,  0.64513542],
       [ 0.00828754,  0.44283754,  0.14946128]])

hsplit 用来分隔矩阵,如果只有一个参数,则将其均等分隔,如果有两个参数,则第一个参数指定分隔后第一个子矩阵的列数据,
第二个参数是最后一个矩阵从第几列开始生成.
In [19]:  b = np.hsplit(b, 3)

In [20]: b
Out[20]:
[array([[ 8.,  7.,  6.,  1.],
       [ 0.,  0.,  2.,  0.]]),
 array([[ 9.,  2.,  2.,  5.],
       [ 1.,  3.,  3.,  2.]]),
 array([[ 2.,  2.,  4.,  2.],
       [ 3.,  0.,  7.,  0.]])]


In [18]: np.hsplit(b, (4, 5))
Out[18]:
[array([[ 8.,  7.,  6.,  1.],
       [ 0.,  0.,  2.,  0.]]),
 array([[ 9.],
       [ 1.]]),
 array([[ 2.,  2.,  5.,  2.,  2.,  4.,  2.],
       [ 3.,  3.,  2.,  3.,  0.,  7.,  0.]])]


拷贝和视图:
赋值语句并没有进行拷贝,两个矩阵是同一个矩阵
In [33]: a = np.arange(12)

In [34]: a
Out[34]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

In [35]: a.shape
Out[35]: (12,)

In [36]: b = a

In [37]: b.shape = 3,4

In [38]: b
Out[38]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [39]: a.shape
Out[39]: (3, 4)

view函数可以将矩阵进行深拷贝
In [40]: id(a)
Out[40]: 39454736

In [41]: id(b)
Out[41]: 39454736

In [42]: c = a.view()

In [43]: c
Out[43]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [44]: id(c)
Out[44]: 40747648


s[:]获取整个矩阵,也是浅拷贝
In [46]: s = a[:, 1:3]
In [48]: s[:]
Out[48]:
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10]])


In [49]: s[:] = 10

In [50]: s
Out[50]:
array([[10, 10],
       [10, 10],
       [10, 10]])

In [52]: a
Out[52]:
array([[ 0, 10, 10,  3],
       [ 4, 10, 10,  7],
       [ 8, 10, 10
      
几种深拷贝的情况
(1)copy函数

In [3]: a
Out[3]: array([0, 1, 2, 3, 4, 5, 6, 7])

In [4]: id(a)
Out[4]: 41090784

In [5]: d = a.copy()

In [6]: d is a
Out[6]: False

In [7]: id(d)
Out[7]: 40958544

将array作为下标来筛选数据

In [8]: a
Out[8]: array([0, 1, 2, 3, 4, 5, 6, 7])

In [9]: i = np.array([1,3,5])

In [10]: a[i]
Out[10]: array([1, 3, 5])

In [12]: i = np.array([[1,3,5],[2,4,6]])

In [13]: a[i]
Out[13]:
array([[1, 3, 5],
       [2, 4, 6]])
      
a数组可以是多维数组,用来表示某些特殊的含义如: 颜色点
In [6]: import numpy as np

In [7]: palette = np.array([[0,0,0], [255,0,0], [0,255.0], [0,0,255], [255,255,255]])
(0,0,0)代表黑点

In [8]: image = np.array([[0, 1,2,0], [0, 3,4,0]])
(0,1,2,0)代表一排点为: 黑,红,绿,白

In [9]: palette[image]
Out[9]:
array([[[0, 0, 0], [255, 0, 0], [0, 255.0], [0, 0, 0]],
       [[0, 0, 0], [0, 0, 255], [255, 255, 255], [0, 0, 0]]], dtype=object)

每张图片都是有一排排的点组成的.

上面的情况是每次选取一行的点,即选取的为维度为0,我们还可以索引多维的点, 即搜索任意一个点

In [13]: i = np.array([[0, 1], [1, 2]])

In [14]: j = np.array([[2, 1], [3, 3]])

In [15]: a[i,j]
Out[15]:
array([[ 2,  5],
       [ 7, 11]])

i和j必须有相同的shape,i代表取的是第几行的点,j代表的是取的是第几列的点.
a是3*4d的二维矩阵,代表引用的参数最多有2个,第一个的范围是0-2,第二个的范围
是0-3,i和j的shape决定了结果的shape.

In [16]:  a[i, 2]
Out[16]:
array([[ 2,  6],
       [ 6, 10]])
上面的情况则,代表只取第二列的值,行的取值则由i决定.

In [19]: a[:, j]
Out[19]:
array([[[ 2,  1],
        [ 3,  3]],

       [[ 6,  5],
        [ 7,  7]],

       [[10,  9],
        [11, 11]]])

上面的情况则代表i的取值为0,1,2 时,去用j的值创建新矩阵

In [20]: a
Out[20]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [21]: ind = a.argmax()

In [22]: ind
Out[22]: 11

In [23]: ind = a.argmax(axis=0)

In [24]: ind
Out[24]: array([2, 2, 2, 2])

In [25]: ind = a.argmax(axis=1)

In [26]: ind
Out[26]: array([3, 3, 3])

argmax返回最大值,或索引,axis为0时 返回每一列的最大值的索引,
为1时 返回每一行的最大值的索引,默认返回最大值.

对索引的数据进行算术运算.
In [54]: a
Out[54]: array([0, 1, 2, 3, 4])

In [55]: a[[0, 2, 3]] += 1

In [56]: a
Out[56]: array([1, 1, 3, 4, 4])

对矩阵进行逻辑判断,返回bool型的相同维度的矩阵.
In [59]: b = a > 4

In [60]: b
Out[60]:
array([[False, False, False, False],
       [False,  True,  True,  True],
       [ True,  True,  True,  True]], dtype=bool)

将值的true的值转为一维矩阵输出
In [61]: a[b]
Out[61]: array([ 5,  6,  7,  8,  9, 10, 11])

也可以将原位置的值进行修改

In [62]: a[b] = 0

In [63]: a
Out[63]:
array([[0, 1, 2, 3],
       [4, 0, 0, 0],
       [0, 0, 0, 0]])
      
使用bool型矩阵进行数据过滤
In [73]: b1 = np.array([False, True, True])

In [74]: b2 = np.array([True, False, True, False])

In [75]: a[b1]
Out[75]:
array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [76]: a[b1, :]
Out[76]:
array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [129]: a
Out[129]: array([1, 2])

In [130]: b
Out[130]: array([3, 4])

In [131]: c
Out[131]: array([5, 6])

In [132]: ax
Out[132]:
array([[[1]],

       [[2]]])

In [133]: bx
Out[133]:
array([[[3],
        [4]]])

In [134]: cx
Out[134]: array([[[5, 6]]])

ax, bx cx = np.ix_(a, b, c)
ix_将一组一维矩阵装换为单位向量进行数值计算,维度取决与参数个数
result = ax + bx * cx

In [135]: result
Out[135]:
array([[[ 8,  9],
        [ 9, 10]],

       [[11, 12],
        [13, 14]]])

transpose 用来重新设置维度,二维默认参数为(1, 0),原数值默认维度为0,1
In [142]: a.transpose([2, 1,0])
Out[142]:
array([[[ 0, 12],
        [ 4, 16],
        [ 8, 20]],

       [[ 1, 13],
        [ 5, 17],
        [ 9, 21]],

       [[ 2, 14],
        [ 6, 18],
        [10, 22]],

       [[ 3, 15],
        [ 7, 19],
        [11, 23]]])

In [143]: a
Out[143]:
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

eye用来生成对角矩阵,第一个参数为矩阵规模,k为第三个矩阵,决定为1的位置,默认为最长的对角线
为全1, 如果为正数,则向右上角位置平移,如果为负数,则向左下角位置平移.
In [144]: np.eye(3, k=1)
Out[144]:
array([[ 0.,  1.,  0.],
       [ 0.,  0.,  1.],
       [ 0.,  0.,  0.]])

In [145]: np.eye(3, k=-1)
Out[145]:
array([[ 0.,  0.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  1.,  0.]])

shape中的-1代表有其他参数自动计算而出.
>>> import numpy as np
>>> a = np.arange(30).reshape(2, -1, 3)
>>> a
array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8],
        [ 9, 10, 11],
        [12, 13, 14]],

       [[15, 16, 17],
        [18, 19, 20],
        [21, 22, 23],
        [24, 25, 26],
        [27, 28, 29]]])
>>> a.shape
(2, 5, 3)
